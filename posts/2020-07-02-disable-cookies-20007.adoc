---
layout: post
title: "Disable LTPA cookie for TAI/SPNEGO or JWT cookie for jwtSso-1.0 on Open Liberty 20.0.0.7"
categories: blog
author_picture: https://avatars3.githubusercontent.com/tomjenningss
author_github: https://github.com/tomjenningss
seo-title: Disable LTPA cookie for TAI/SPNEGO or JWT cookie for jwtSso-1.0 on Open Liberty 20.0.0.7 - OpenLiberty.io
seo-description: With Open Liberty 20.0.0.7 users have the availability to configure the return LPTA cookie for TAI/SPNEGO or JWT cookie for jwtSso-1.0.
blog_description: With Open Liberty 20.0.0.7 users have the availability to configure the return LPTA cookie for TAI/SPNEGO or JWT cookie for jwtSso-1.0.
---
= Disable LTPA cookie for TAI/SPNEGO or JWT cookie for jwtSso-1.0 on Open Liberty 20.0.0.7
Tom Jennings <https://github.com/tomjenningss>
:imagesdir: /
:url-prefix:
:url-about: /about/

// tag::intro[]

With Open Liberty 20.0.0.7 users have the availability to configure the return LPTA cookie for TAI/SPNEGO or JWT cookie for jwtSso-1.0.

In link:{url-about}[Open Liberty] 20.0.0.7:

* <<LTPA-cookie, Choose to disable LTPA cookie for TAI/SPNEGO>>
* <<JWT-cookie, Choose to disable JWT cookie for jwtSso-1.0 feature>>

View the list of fixed bugs in link:https://github.com/OpenLiberty/open-liberty/issues?q=label%3Arelease%3A20007+label%3A%22release+bug%22+[20.0.0.7].

If you're interested in what's coming soon in Open Liberty, take a look at our <<previews,current development builds>> which include gRPC with Open Liberty.
// end::intro[]

// tag::run[]
[#run]

== Run your apps using 20.0.0.7

If you're using link:{url-prefix}/guides/maven-intro.html[Maven], here are the coordinates:

[source,xml]
----
<dependency>
    <groupId>io.openliberty</groupId>
    <artifactId>openliberty-runtime</artifactId>
    <version>20.0.0.7</version>
    <type>zip</type>
</dependency>
----

Or for link:{url-prefix}/guides/gradle-intro.html[Gradle]:

[source,gradle]
----
dependencies {
    libertyRuntime group: 'io.openliberty', name: 'openliberty-runtime', version: '[20.0.0.7,)'
}
----

Or if you're using Docker:

[source]
----
FROM open-liberty
----
//end::run[]

Or take a look at our link:{url-prefix}/downloads/[Downloads page].

[link=https://stackoverflow.com/tags/open-liberty]
image::img/blog/blog_btn_stack.svg[Ask a question on Stack Overflow, align="center"]

//tag::features[]

[#LTPA-cookie]
=== Choose to disable LTPA cookie for TAI/SPNEGO

LTPA cookie encapsulate an encrypted authentication token containing the user identity and expiration information and can be user for single sign-on (SSO). Users now have the option to decide to receive the LTPA cookie for TAI and SPNEGO authentication.

When a browser client is authenticated with an Open Liberty server, the default response is the SSO LTPA cookie in the HTTP servlet. When the same browser client accesses another protected resource in the Open Liberty server that shares the same LTPA config, authentication with the SSO LTPA cookie happens first before any other authentication mechanism. This can potentially cause un-intented result in some situation that require the other authentication mechanism to be used. The update allows users to disable the creation of LTPA cookie for TAI and SPNEGO authentication.

Disable LTPA cookie for TAI `server.xml`:

[source, xml]
----
<server>
  <featureManager>
    <feature>appSecurity-2.0</feature>
  </featureManager>
  <trustAssociation id="sample" disableLtpaCookie="true" />
</server>
----

Disable LTPA cookie for SPNEGO `server.xml`:

[source, xml]
----
<server>
  <featureManager>
    <feature>spnego-1.0</feature>
  </featureManager>
  <spnego id="sample" disableLtpaCookie="true" />
</server>
----

//end::features[]

[#JWT-cookie]
=== Choose to disable JWT cookie for jwtSso-1.0 feature

When a browser client is authenticated with an Open Liberty server through the `jwtSso-1.0` feature, the default response is the SSO JWT cookie in the HTTP servlet. When the same browser client accesses another protected resource in the same or different Open Liberty server, authentication with the SSO JWT cookie happens first before any other authentication mechanism. This can potentially cause un-intented result in some situations that require the other authentication mechanism to be used. The update allows users to disable JWT cookie for `jwtSso-1.0` feature.

Add the feature to the `server.xml`:

[source, xml]
----
<server>
  <featureManager>
    <feature>jwtSso-1.0</feature>
  </featureManager>
  <jwtSso id="sample" disableJwtCookie="true" />
</server>
----

//end::features[]

=== Notable bug fixes and enhancements in JAX-RS 2.1

If you've been seeing a `NullPointerException` when writing multipart form data in your JAX-RS response, we've got good news for you - we fixed that in issue link:https://github.com/OpenLiberty/open-liberty/issues/8048[8048]!
One of our users needed a clever way to restrict JSON field serialization by a user's security role. By using a `ContextResolver` for specifying the JSON-B visibility strategy and injecting the `SecurityContext`, they were able to make this work. Only one problem - the injection into the ContextResolver wasn't working… We fixed that too! Check out issue https://github.com/OpenLiberty/open-liberty/issues/12715[12715]. It's a pretty cool use case!

=== Improvements to HTTP2 Implementation 

A scenario was reported where excess CPU consumption is seen when a client does not terminate a HTTP/2 connection gracefully.  We've resolved this in issue link:https://github.com/OpenLiberty/open-liberty/issues/12599[12599]
In some specific cases, Liberty does not update its HTTP/2 read window quickly enough, causing the flow control window to stall.  We have improved Liberty's flow control behavior with link:https://github.com/OpenLiberty/open-liberty/issues/12399[12399]

[#previews]
== Previews of early implementations available in development builds

You can now also try out early implementations of some new capabilities in the link:https://openliberty.io/downloads/#development_builds[latest Open Liberty development builds]:

* <<grpc, Try out the new grpc-1.0 and grpcClient-1.0 features>>
* <<AJWW, Allow JSON written to System.out to pass without wrapping>>
* <<ALFJ, HTTP access log fields in JSON logs>>

These early implementations are not available in 20.0.0.7, but you can try them out in our daily Docker image by running `docker pull openliberty/daily`. Let us know what you think!

[#grpc]
=== Try out the new grpc-1.0 and grpcClient-1.0 features

You can now try out the new gRPC and gRPC client.

link:https://grpc.io/docs/what-is-grpc/introduction/[gRPC] is a high-performance, open source universal link:https://www.smashingmagazine.com/2016/09/understanding-rest-and-rpc-for-http-apis/[RPC] framework. gRPC support on Liberty allows developers to both provide and consume gRPC services from their web applications. The introduction of gRPC support in Open Liberty now means developers can take advantage of the benefits of gRPC more easily than before. Those benefits include great performance, simple service definitions via Protocol Buffers, cross-platform and language support, and wide industry adoption.

Two new features are available in beta: `grpc-1.0`, which enables gRPC services, and `grpcClient-1.0`, which enables the use of a gRPC client for outbound calls.

Add the features to the `server.xml`:

[source, xml]
----
<server>
  <featureManager>
    <feature>grpc-1.0</feature>
    <feature>grpcClient-1.0</feature>
  </featureManager>
</server>
----

The `grpc-1.0` feature works by scanning web apps for gRPC service implementations, through implementors of `io.grpc.BindableService`. The web app must include the protocol buffer compiler-generated code for the services it intends to provide, and additionally the service class must provide a no-argument constructor. The web app does not need to include any core gRPC libraries; those are provided by the Liberty runtime. Once a gRPC service is scanned and started, it becomes accessible to remote gRPC clients on the configured HTTP ports.

The `grpcClient-1.0` feature provides applications with access to a link:https://netty.io/[Netty] gRPC client, as well as the related libraries. A web app must provide a client implementation and stubs, and can make outbound calls with a `io.grpc.ManagedChannel` without needing to provide the supporting client libraries.

Try out gRPC with the following basic Hello World service (add the  `grpc-1.0` to the `server.xml`):

[source, java]
----
package com.ibm.ws.grpc;

import com.ibm.ws.grpc.beans.GreetingBean;

import io.grpc.examples.helloworld.GreeterGrpc;
import io.grpc.examples.helloworld.HelloReply;
import io.grpc.examples.helloworld.HelloRequest;
import io.grpc.stub.StreamObserver;

public class HelloWorldService extends GreeterGrpc.GreeterImplBase {

    public HelloWorldService(){}

    @Override
    public void sayHello(HelloRequest req, StreamObserver<HelloReply> responseObserver) {
        HelloReply reply = HelloReply.newBuilder().setMessage("Hello " + req.getName()).build();
        responseObserver.onNext(reply);
        responseObserver.onCompleted();
    }
}
----

For this example, the application must provide the link:https://github.com/grpc/grpc-java/blob/master/examples/src/main/proto/helloworld.proto[helloworld protof definition] along with the protobuf compiler output. No additional libraries need to be provided with the application, and once it's started the helloworld greeter service will be accessible on the server's HTTP endpoints.

For a client example, a basic Servlet using gRPC can be defined via `grpcClient-1.0` with:

[source, java]
----
package com.ibm.ws.grpc;

import io.grpc.examples.helloworld.GreeterGrpc;
import io.grpc.examples.helloworld.HelloReply;
import io.grpc.examples.helloworld.HelloRequest;

import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
...
@WebServlet(name = "grpcClient", urlPatterns = { "/grpcClient" }, loadOnStartup = 1)
public class GrpcClientServlet extends HttpServlet {

        ManagedChannel channel;
        private GreeterGrpc.GreeterBlockingStub greetingService;

        private void startService(String address, int port) 
        {
            channel = ManagedChannelBuilder.forAddress(address , port).usePlaintext().build();
            greetingService = GreeterGrpc.newBlockingStub(channel);
        }

        private void stopService() 
        {
            channel.shutdownNow();
        }

        @Override
        protected void doGet(HttpServletRequest reqest, HttpServletResponse response) 
            throws ServletException, IOException 
        {

            // set user, address, port params
        }

        @Override
        protected void doPost(HttpServletRequest request, HttpServletResponse response) 
            throws ServletException, IOException 
        {

        // grab user, address, port params
        startService(address, port);
        HelloRequest person = HelloRequest.newBuilder().setName(user).build();
        HelloReply greeting = greetingService.sayHello(person);

        // send the greeting in a response
        stopService();
        }	
    }
}
----

As with the service example, the application must provide the link:https://github.com/grpc/grpc-java/blob/master/examples/src/main/proto/helloworld.proto[helloworld protof definition] along with the protobuf compiler output. All required gRPC client libraries are provided by `grpcClient-1.0`.

[#AJWW]
=== Allow JSON written to System.out to pass without wrapping

Open Liberty provides developers with the option to format their server logs in basic or JSON format. When the logs are in JSON format, developers have to specify the sources (`message`, `trace`, `accessLog`, `ffdc`, `audit`) they want to send to `messages.log` or `console.log/standard-out`.

When Open Liberty is running with JSON logging enabled, currently Open Liberty embeds anything written to `System.out/System.err` into the message field of a `liberty_message` event. Now, developers can write JSON directly to `System.out/err` without wrapping in the `liberty_message` event. The JSON can be sent to a log analysis tool, such as the ELK (Elasticsearch, Logstash, Kibana) stack. 

Enable this functionality any time by setting `appsWriteJson="true"` in the logging element of the `server.xml`, or can have it set from the moment the server starts by setting it in the `bootstrap.properties`:
`com.ibm.ws.logging.apps.write.json=true`

Previously, when JSON logging is enabled, pre-formatted JSON application logs would look like this:
[source, xml]
---
{
     "type":"liberty_message",
     "host":"192.168.0.119",
     "ibm_userDir":"\/Users\/yushan.lin@ibm.com\/Documents\/archived-guide-log4j\/finish\/target\/liberty\/wlp\/usr\/",
     "ibm_serverName":"log4j.sampleServer",
     "message":"{\n   \"timeMillis\" : 1587666082123,\n  
             \"thread\" : \"Default Executor-thread-8\",\n  
             \"level\" : \"WARN\",\n  
              \"loggerName\" : \"application.servlet.LibertyServlet\",\n  
              \"message\" : \"hello liberty servlet warning message!\",\n  
              \"endOfBatch\" : false,\n  
              \"loggerFqcn\" : \"org.apache.logging.log4j.spi.AbstractLogger\",\n  
              \"threadId\" : 53,\n  
              \"threadPriority\" : 5\n}\r",
     "ibm_threadId":"00000035",
     "ibm_datetime":"2020-04-23T14:21:22.124-0400",
     "module":"SystemOut",
     "loglevel":"SystemOut",
     "ibm_methodName":"",
     "ibm_className":"",
     "ibm_sequence":"1587666082124_000000000001B",
     "ext_thread":"Default Executor-thread-8”
}
---

Visualization tools such as Kibana can be used to analyze certain fields in the JSON logs. Users can analyze both custom-formatted JSON application logs and Open Liberty JSON logs in the same visualization. To learn more about JSON logging, link:https://openliberty.io/docs/ref/config/#logging.html[view the documentation.]

[#ALFJ]
=== HTTP access log fields in JSON logs

Open Liberty provides options to format server logs in basic or JSON format. Choosing logs in JSON format means developers have to specify the sources they want to send to `messages.log` or `console.log/standard-out`. Previously only select fields would be printed in JSON logs. Now options to include fields from the `accessLogging logFormat` attribute in the JSON logs is now available. The ability to include other NCSA access log fields in the JSON logs is now available. 

Users can now define which JSON access log fields they want from the `accessLogging logFormat` property, which can then be sent to a log analysis tool, such as the ELK (Elasticsearch, Logstash, Kibana) stack. This allows more informative logs suiting the users needs. Users can specify that they want the user ID and request time fields in the JSON access logs allowing a filter by user ID feature in Kibana and track performance on a user-by-user basis. 

When logs are in JSON format, use the new `jsonAccessLogFields` logging attribute to specify whether you want your access logs to have the default set of fields, or a custom set of fields based on the HTTP `accessLogging logFormat` attribute. To receive access logs, the property `accessLogging` or `httpAccessLogging` has to be set. 

Set the following attributes in the `server.xml`:

[source, xml]
---
    <httpEndpoint id="defaultHttpEndpoint" httpPort="9080" httpsPort="9443" host="\*\">
        <accessLogging logFormat='%R{W} %u %{my_cookie}C %s'/>
    </httpEndpoint>
    <logging messageFormat="json" messageSource="message,accessLog" jsonAccessLogFields="logFormat"/>
---

Now, in the `messages.log file`, the access logs will contain the four fields specified in the `accessLogging logFormat` attribute (elapsed time, user ID, cookie, and response code):

[source, xml]
----
{
  "type": "liberty_accesslog",
  "host": "192.168.1.15",
  "ibm_userDir": "/Users/jennifer.zhen.chengibm.com/libertyGit/open-liberty/dev/build.image/wlp/usr/",
  "ibm_serverName": "defaultServer",
  "ibm_cookie_my_cookie": "example_cookie",
  "ibm_responseCode": 200,
  "ibm_datetime": "2020-06-18T09:30:47.693-0400",
  "ibm_sequence": "1592487047653_0000000000001"
}
----

The new functionality is also available for the `logstashCollector-1.0` feature by adding the following to the `server.xml`:

[source,xml]
----
    <featureManager>
        <feature>logstashCollector-1.0</feature>
    </featureManager>

    <logstashCollector 
        jsonAccessLogFields="logFormat">
----

== Get Open Liberty 20.0.0.7 now

Available through <<run,Maven, Gradle, Docker, and as a downloadable archive>>.
